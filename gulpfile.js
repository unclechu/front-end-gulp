// Generated by LiveScript 1.3.1
/**
 * @version r9
 * @author Viacheslav Lotsmanov
 * @license GNU/GPLv3 (https://github.com/unclechu/web-front-end-gulp-template/blob/master/LICENSE)
 * @see {@link https://github.com/unclechu/web-front-end-gulp-template|GitHub}
 */
(function(){
  var path, fs, gulp, plumber, argv, merge, gcb, del, spritesmith, tasks, less, sourcemaps, stylus, nib, gulpif, rename, browserify, liveify, uglify, jshint, stylish, pkg, production, ignoreErrors, renameBuildFile, initTaskIteration, initWatcherTask, cleanData, distCleanData, spritesCleanTasks, spritesBuildTasks, spritesData, spriteCleanTask, spriteBuildTask, spriteInitTasks, name, item, stylesCleanTasks, stylesBuildTasks, stylesWatchTasks, stylesData, stylesCleanTask, stylesBuildTask, stylesInitTasks, scriptsCleanTasks, scriptsBuildTasks, scriptsWatchTasks, scriptsData, scriptsCleanTask, scriptsJshintTask, scriptsBuildBrowserifyTask, scriptsInitTasks;
  path = require('path');
  fs = require('fs');
  gulp = require('gulp');
  plumber = require('gulp-plumber');
  argv = require('yargs').argv;
  merge = require('merge-stream');
  gcb = require('gulp-callback');
  del = require('del');
  spritesmith = require('gulp.spritesmith');
  tasks = require('gulp-task-listing');
  less = require('gulp-less');
  sourcemaps = require('gulp-sourcemaps');
  stylus = require('gulp-stylus');
  nib = require('nib');
  gulpif = require('gulp-if');
  rename = require('gulp-rename');
  browserify = require('gulp-browserify');
  liveify = require('liveify');
  uglify = require('gulp-uglify');
  jshint = require('gulp-jshint');
  stylish = require('jshint-stylish');
  pkg = require(path.join(process.cwd(), './package.json'));
  gulp.task('help', tasks);
  production = argv.production != null;
  ignoreErrors = argv['ignore-errors'] != null;
  renameBuildFile = function(buildPath, mainSrc, buildFile){
    if (buildPath.basename === path.basename(mainSrc, path.extname(mainSrc))) {
      buildPath.extname = path.extname(buildFile);
      buildPath.basename = path.basename(buildFile, buildPath.extname);
    }
  };
  initTaskIteration = function(name, item, initFunc){
    var subTaskName, ref$, subTask, subTaskParams, key, val;
    initFunc(name, item);
    if (item.subTasks) {
      for (subTaskName in ref$ = item.subTasks) {
        subTask = ref$[subTaskName];
        subTaskParams = clone$(item);
        subTaskParams.subTask = null;
        for (key in subTask) {
          val = subTask[key];
          subTaskParams[key] = val;
        }
        initFunc(name + '-' + subTaskName, subTaskParams, true);
      }
    }
  };
  initWatcherTask = function(subTask, watchFiles, addToWatchersList, watchTaskName, watchersList, buildTaskName){
    var addToList;
    addToList = false;
    if (addToWatchersList === true) {
      addToList = true;
    } else if (!subTask && addToWatchersList !== false) {
      addToList = true;
    }
    gulp.task(watchTaskName, function(){
      ignoreErrors = true;
      gulp.watch(watchFiles, [buildTaskName]);
    });
    if (addToList) {
      watchersList.push(watchTaskName);
    }
  };
  cleanData = pkg.gulp.clean || [];
  distCleanData = pkg.gulp.distclean || [];
  gulp.task('clean', ['clean-sprites', 'clean-styles', 'clean-scripts'], function(cb){
    del(cleanData, cb);
  });
  gulp.task('distclean', ['clean'], function(cb){
    del(distCleanData, cb);
  });
  spritesCleanTasks = [];
  spritesBuildTasks = [];
  spritesData = pkg.gulp.sprites || {};
  spriteCleanTask = function(name, spriteParams, params, cb){
    var toRemove;
    toRemove = [path.join(params.cssDir, spriteParams.cssName)];
    if (params.imgDestDir != null) {
      toRemove.push(path.join(params.imgDestDir, spriteParams.imgName));
    } else {
      toRemove.push(path.join(params.imgDir, 'build'));
    }
    del(toRemove, {
      force: true
    }, cb);
  };
  spriteBuildTask = function(name, spriteParams, params, cb){
    var spriteData, ready, postCb, imgDest;
    spriteData = gulp.src(path.join(params.imgDir, 'src/*.png')).pipe(gulpif(ignoreErrors, plumber({
      errorHandler: cb
    }))).pipe(spritesmith(spriteParams));
    ready = {
      img: false,
      css: false
    };
    postCb = function(){
      if (!ready.img || !ready.css) {
        return;
      }
      cb();
    };
    imgDest = path.join(params.imgDir, 'build');
    if (params.imgDestDir != null) {
      imgDest = params.imgDestDir;
    }
    spriteData.img.pipe(gulp.dest(imgDest)).pipe(gcb(function(){
      ready.img = true;
      postCb();
    }));
    spriteData.css.pipe(gulp.dest(params.cssDir)).pipe(gcb(function(){
      ready.css = true;
      postCb();
    }));
  };
  spriteInitTasks = function(name, item, subTask){
    var imgName, spriteParams, params, cleanTaskName, buildTaskName, preBuildTasks, i$, ref$, len$, taskName;
    subTask == null && (subTask = false);
    imgName = item.imgName || 'sprite.png';
    spriteParams = {
      imgName: imgName,
      cssName: item.cssName || name + '.css',
      imgPath: path.join(item.imgPathPrefix, 'build', imgName),
      padding: item.padding || 1,
      imgOpts: {
        format: 'png'
      },
      cssVarMap: (function(name){
        return function(s){
          s.name = 'sprite-' + name + '-' + s.name;
        };
      }.call(this, name)),
      algorithm: item.algorithm || 'top-down'
    };
    params = {
      imgDir: item.imgDir,
      cssDir: item.cssDir,
      imgDestDir: item.imgDestDir || null
    };
    cleanTaskName = 'clean-sprite-' + name;
    buildTaskName = 'sprite-' + name;
    preBuildTasks = [cleanTaskName];
    if (item.buildDeps) {
      for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
        taskName = ref$[i$];
        preBuildTasks.push(taskName);
      }
    }
    gulp.task(cleanTaskName, (function(name, spriteParams, params){
      return function(cb){
        spriteCleanTask(name, spriteParams, params, cb);
      };
    }.call(this, name, spriteParams, params)));
    gulp.task(buildTaskName, preBuildTasks, (function(name, spriteParams, params){
      return function(cb){
        spriteBuildTask(name, spriteParams, params, cb);
      };
    }.call(this, name, spriteParams, params)));
    spritesCleanTasks.push(cleanTaskName);
    if (!subTask) {
      spritesBuildTasks.push(buildTaskName);
    }
  };
  for (name in spritesData) {
    item = spritesData[name];
    initTaskIteration(name, item, spriteInitTasks);
  }
  gulp.task('clean-sprites', spritesCleanTasks);
  gulp.task('sprites', spritesBuildTasks);
  stylesCleanTasks = [];
  stylesBuildTasks = [];
  stylesWatchTasks = [];
  stylesData = pkg.gulp.styles || {};
  stylesCleanTask = function(name, params, cb){
    var toRemove;
    if (params.destDir != null) {
      toRemove = path.join(params.destDir, params.buildFile);
    } else {
      toRemove = path.join(params.path, 'build');
    }
    del(toRemove, {
      force: true
    }, cb);
  };
  stylesBuildTask = function(name, params, cb){
    var options, sourceMaps, sourceMapsAsPlugin, destDir, srcDir, srcPath;
    options = {
      compress: production
    };
    sourceMaps = false;
    if (params.sourceMaps === true) {
      sourceMaps = true;
    } else if (!production && params.sourceMaps !== false) {
      sourceMaps = true;
    }
    sourceMapsAsPlugin = false;
    if (params.type === 'stylus') {
      options.use = nib();
      if (sourceMaps) {
        options.sourcemap = {
          inline: true,
          sourceRoot: '.',
          basePath: path.join(params.path, 'src')
        };
      }
    } else if (params.type === 'less' && sourceMaps) {
      sourceMapsAsPlugin = true;
    }
    destDir = path.join(params.path, 'build');
    if (params.destDir != null) {
      destDir = params.destDir;
    }
    srcDir = path.join(params.path, 'src');
    if (params.srcDir != null) {
      srcDir = params.srcDir;
    }
    srcPath = path.join(srcDir, params.mainSrc);
    fs.exists(srcPath, function(exists){
      if (!exists) {
        throw new Error("Source path '" + srcPath + "' is not exists");
      }
      gulp.src(srcPath).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(gulpif(sourceMapsAsPlugin, sourcemaps.init())).pipe(gulpif(params.type === 'less', less(options))).pipe(gulpif(sourceMapsAsPlugin, sourcemaps.write())).pipe(gulpif(params.type === 'stylus', stylus(options))).pipe(rename(function(buildPath){
        renameBuildFile(buildPath, params.mainSrc, params.buildFile);
      })).pipe(gulp.dest(destDir)).pipe(gcb(cb));
    });
  };
  stylesInitTasks = function(name, item, subTask){
    var params, cleanTaskName, buildTaskName, watchTaskName, preBuildTasks, i$, ref$, len$, taskName, srcPath, watchFiles;
    subTask == null && (subTask = false);
    params = {
      type: item.type,
      path: item.path,
      mainSrc: item.mainSrc,
      srcDir: item.srcDir || null,
      buildFile: item.buildFile,
      destDir: item.destDir || null
    };
    if (typeof item.sourceMaps === 'boolean') {
      params.sourceMaps = item.sourceMaps;
    }
    cleanTaskName = 'clean-styles-' + name;
    buildTaskName = 'styles-' + name;
    watchTaskName = buildTaskName + '-watch';
    preBuildTasks = [cleanTaskName];
    if (item.buildDeps) {
      for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
        taskName = ref$[i$];
        preBuildTasks.push(taskName);
      }
    }
    gulp.task(cleanTaskName, (function(name, params){
      return function(cb){
        stylesCleanTask(name, params, cb);
      };
    }.call(this, name, params)));
    if (item.type === 'less' || item.type === 'stylus') {
      gulp.task(buildTaskName, preBuildTasks, (function(name, params){
        return function(cb){
          stylesBuildTask(name, params, cb);
        };
      }.call(this, name, params)));
    } else {
      throw new Error("Unknown styles type for '" + name + "' task.");
    }
    stylesCleanTasks.push(cleanTaskName);
    if (!subTask) {
      stylesBuildTasks.push(buildTaskName);
    }
    srcPath = path.join(params.path, 'src');
    if (item.watchFiles != null) {
      watchFiles = item.watchFiles;
    } else if (item.type === 'less') {
      watchFiles = path.join(srcPath, '**/*.less');
    } else if (item.type === 'stylus') {
      watchFiles = [path.join(srcPath, '**/*.styl'), path.join(srcPath, '**/*.stylus')];
    }
    initWatcherTask(subTask, watchFiles, item.addToWatchersList, watchTaskName, stylesWatchTasks, buildTaskName);
  };
  for (name in stylesData) {
    item = stylesData[name];
    initTaskIteration(name, item, stylesInitTasks);
  }
  gulp.task('clean-styles', stylesCleanTasks);
  gulp.task('styles', stylesBuildTasks);
  gulp.task('styles-watch', stylesWatchTasks);
  scriptsCleanTasks = [];
  scriptsBuildTasks = [];
  scriptsWatchTasks = [];
  scriptsData = pkg.gulp.scripts || {};
  scriptsCleanTask = function(name, params, cb){
    var toRemove;
    if (params.destDir != null) {
      toRemove = path.join(params.destDir, params.buildFile);
    } else {
      toRemove = path.join(params.path, 'build');
    }
    del(toRemove, {
      force: true
    }, cb);
  };
  scriptsJshintTask = function(name, params, cb){
    var src, i$, ref$, len$, exclude;
    src = [path.join(params.path, 'src/**/*.js')];
    for (i$ = 0, len$ = (ref$ = params.jshintExclude).length; i$ < len$; ++i$) {
      exclude = ref$[i$];
      src.push('!' + exclude);
    }
    gulp.src(src).pipe(jshint(params.jshintParams)).pipe(jshint.reporter(stylish)).pipe(rename('x')).end(cb);
  };
  scriptsBuildBrowserifyTask = function(name, params, cb){
    var options, destDir, srcDir, srcPath;
    options = {
      shim: params.shim,
      debug: false
    };
    if (params.debug === true) {
      options.debug = true;
    } else if (!production && params.debug !== false) {
      options.debug = true;
    }
    if (params.type === 'liveify') {
      options.transform = ['liveify'];
      options.extensions = ['.ls'];
      options.shim.prelude = {
        path: './node_modules/prelude-ls',
        exports: ''
      };
    }
    destDir = path.join(params.path, 'build');
    if (params.destDir != null) {
      destDir = params.destDir;
    }
    srcDir = path.join(params.path, 'src');
    if (params.srcDir != null) {
      srcDir = params.srcDir;
    }
    srcPath = path.join(srcDir, params.mainSrc);
    fs.exists(srcPath, function(exists){
      if (!exists) {
        throw new Error("Source path '" + srcPath + "' is not exists");
      }
      gulp.src(srcPath, {
        read: false
      }).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(browserify(options)).pipe(gulpif(production, uglify({
        preserveComments: 'some'
      }))).pipe(rename(function(buildPath){
        renameBuildFile(buildPath, params.mainSrc, params.buildFile);
      })).pipe(gulp.dest(destDir)).pipe(gcb(cb));
    });
  };
  scriptsInitTasks = function(name, item, subTask){
    var key, ref$, shimItem, paramName, val, params, i$, len$, exclude, cleanTaskName, buildTaskName, jshintTaskName, watchTaskName, preBuildTasks, taskName, srcPath, watchFiles;
    subTask == null && (subTask = false);
    if (item.shim) {
      for (key in ref$ = item.shim) {
        shimItem = ref$[key];
        for (paramName in shimItem) {
          val = shimItem[paramName];
          if (paramName === 'relativePath') {
            shimItem.path = path.join(item.path, 'src', val);
            delete shimItem[paramName];
          }
        }
      }
    }
    params = {
      type: item.type,
      path: item.path,
      mainSrc: item.mainSrc,
      srcDir: item.srcDir || null,
      buildFile: item.buildFile,
      destDir: item.destDir || null,
      shim: item.shim || {},
      jshintDisabled: item.jshintDisabled && true || false,
      jshintParams: item.jshintParams && item.jshintParams || null,
      jshintExclude: item.jshintExclude && item.jshintExclude || []
    };
    if (item.type === 'liveify') {
      params.jshintExclude.push(path.join(item.path, 'src/**/*.ls'));
    }
    if (item.jshintRelativeExclude) {
      for (i$ = 0, len$ = (ref$ = item.jshintRelativeExclude).length; i$ < len$; ++i$) {
        exclude = ref$[i$];
        params.jshintExclude.push(path.join(item.path, 'src', exclude));
      }
    }
    if (typeof item.debug === 'boolean') {
      params.debug = item.debug;
    }
    cleanTaskName = 'clean-scripts-' + name;
    buildTaskName = 'scripts-' + name;
    jshintTaskName = buildTaskName + '-jshint';
    watchTaskName = buildTaskName + '-watch';
    preBuildTasks = [cleanTaskName];
    if (item.buildDeps) {
      for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
        taskName = ref$[i$];
        preBuildTasks.push(taskName);
      }
    }
    if (!params.jshintDisabled) {
      gulp.task(jshintTaskName, (function(name, params){
        return function(cb){
          scriptsJshintTask(name, params, cb);
        };
      }.call(this, name, params)));
      preBuildTasks.push(jshintTaskName);
    }
    gulp.task(cleanTaskName, (function(name, params){
      return function(cb){
        scriptsCleanTask(name, params, cb);
      };
    }.call(this, name, params)));
    if (item.type === 'browserify' || item.type === 'liveify') {
      gulp.task(buildTaskName, preBuildTasks, (function(name, params){
        return function(cb){
          scriptsBuildBrowserifyTask(name, params, cb);
        };
      }.call(this, name, params)));
    } else {
      throw new Error("Unknown scripts type for '" + name + "' task.");
    }
    scriptsCleanTasks.push(cleanTaskName);
    if (!subTask) {
      scriptsBuildTasks.push(buildTaskName);
    }
    srcPath = path.join(params.path, 'src');
    if (item.watchFiles != null) {
      watchFiles = item.watchFiles;
    } else if (item.type === 'browserify') {
      watchFiles = path.join(srcPath, '**/*.js');
    } else if (item.type === 'liveify') {
      watchFiles = [path.join(srcPath, '**/*.ls'), path.join(srcPath, '**/*.js')];
    }
    initWatcherTask(subTask, watchFiles, item.addToWatchersList, watchTaskName, scriptsWatchTasks, buildTaskName);
  };
  for (name in scriptsData) {
    item = scriptsData[name];
    initTaskIteration(name, item, scriptsInitTasks);
  }
  gulp.task('clean-scripts', scriptsCleanTasks);
  gulp.task('scripts', scriptsBuildTasks);
  gulp.task('scripts-watch', scriptsWatchTasks);
  gulp.task('watch', ['styles-watch', 'scripts-watch']);
  gulp.task('default', ['sprites', 'styles', 'scripts']);
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);
