// Generated by LiveScript 1.4.0
/**
 * @author Viacheslav Lotsmanov
 * @license MIT (https://raw.githubusercontent.com/unclechu/front-end-gulp-pattern/master/LICENSE-MIT)
 * @see {@link https://github.com/unclechu/front-end-gulp-pattern|GitHub}
 */
(function(){
  var path, fs, yargs, gulp, del, tasks, gcb, plumber, gulpif, rename, sourcemaps, argv, pkg, isProductionMode, ignoreErrors, supportedTypes, watchTasks, defaultTasks, cleanTasks, renameBuildFile, initTaskIteration, initWatcherTask, preparePaths, checkForSupportedType, typicalCleanTask, spritesCleanTasks, spritesBuildTasks, spritesWatchTasks, spritesData, ref$, spritePreparePaths, spriteCleanTask, spriteBuildTask, spriteGetNameByMask, spriteInitTasks, name, item, stylesCleanTasks, stylesBuildTasks, stylesWatchTasks, stylesData, stylesCleanTask, stylesBuildTask, stylesInitTasks, scriptsCleanTasks, scriptsBuildTasks, scriptsWatchTasks, scriptsData, scriptsCleanTask, scriptsJshintTask, scriptsBuildBrowserifyTask, scriptsInitTasks, cleanData, distCleanData, distCleanTasks;
  path = require('path');
  fs = require('fs');
  yargs = require('yargs');
  gulp = require('gulp');
  del = require('del');
  tasks = require('gulp-task-listing');
  gcb = require('gulp-callback');
  plumber = require('gulp-plumber');
  gulpif = require('gulp-if');
  rename = require('gulp-rename');
  sourcemaps = require('gulp-sourcemaps');
  argv = yargs['default']({
    production: false,
    ignoreErrors: false
  }).boolean('production').boolean('ignore-errors').argv;
  pkg = require(path.join(process.cwd(), 'package.json'));
  if (pkg.gulp == null) {
    throw new Error('No "gulp" key in package.json');
  }
  gulp.task('help', tasks);
  isProductionMode = argv.production;
  ignoreErrors = argv.ignoreErrors;
  supportedTypes = {
    styles: ['stylus', 'less'],
    scripts: ['browserify']
  };
  watchTasks = [];
  defaultTasks = [];
  cleanTasks = [];
  renameBuildFile = function(buildPath, mainSrc, buildFile){
    if (buildPath.basename === path.basename(mainSrc, path.extname(mainSrc))) {
      buildPath.extname = path.extname(buildFile);
      buildPath.basename = path.basename(buildFile, buildPath.extname);
    }
  };
  initTaskIteration = function(name, item, initFunc){
    var subTaskName, ref$, subTask, subTaskParams;
    initFunc(name, item);
    if (item.subTasks == null) {
      return;
    }
    for (subTaskName in ref$ = item.subTasks) {
      subTask = ref$[subTaskName];
      subTaskParams = importAll$(importAll$(clone$(item), {
        subTask: null
      }), subTask);
      initFunc(name + "-" + subTaskName, subTaskParams, true);
    }
  };
  initWatcherTask = function(subTask, watchFiles, addToWatchersList, watchTaskName, watchersList, buildTaskName){
    var addToList;
    addToList = addToWatchersList === true || (!subTask && addToWatchersList !== false);
    gulp.task(watchTaskName, function(){
      ignoreErrors = true;
      gulp.watch(watchFiles, [buildTaskName]);
    });
    if (addToList) {
      watchersList.push(watchTaskName);
    }
  };
  preparePaths = function(params, cb){
    var destDir, ref$, srcDir, srcFilePath;
    destDir = (ref$ = params.destDir) != null
      ? ref$
      : path.join(params.path, 'build');
    srcDir = (ref$ = params.srcDir) != null
      ? ref$
      : path.join(params.path, 'src');
    srcFilePath = path.join(srcDir, params.mainSrc);
    if (!fs.existsSync(srcFilePath)) {
      throw new Error("Source file '" + srcFilePath + "' is not exists");
    }
    cb(srcFilePath, srcDir, destDir);
  };
  checkForSupportedType = curry$(function(category, type){
    if (supportedTypes[category] == null) {
      throw new Error("Unknown category: '" + category + "'");
    }
    if (!(function(it){
      return in$(it, supportedTypes[category]);
    })(
    type)) {
      throw new Error("Unknown " + category + " type: '" + type + "'");
    }
  });
  typicalCleanTask = function(name, params, cb){
    preparePaths(params, function(srcFilePath, srcDir, destDir){
      var toRemove;
      toRemove = params.destDir != null ? path.join(destDir, params.buildFile) : destDir;
      del(toRemove, {
        force: true
      }, cb);
    });
  };
  spritesCleanTasks = [];
  spritesBuildTasks = [];
  spritesWatchTasks = [];
  spritesData = (ref$ = pkg.gulp.sprites) != null
    ? ref$
    : {};
  spritePreparePaths = function(params, cb){
    var img, data;
    img = Object.create(null);
    data = Object.create(null);
    if (params.path == null) {
      if (params.imgSrcDir == null || params.imgDestDir == null || params.dataDestDir == null) {
        throw new Error('Not enough parameters');
      }
    } else {
      img.srcDir = path.join(params.path, 'src');
      img.destDir = path.join(params.path, 'build');
      data.destDir = path.join(params.path, 'build');
    }
    if (params.imgSrcDir != null) {
      img.srcDir = params.imgSrcDir;
    }
    if (params.imgDestDir != null) {
      img.destDir = params.imgDestDir;
    }
    if (params.dataDestDir != null) {
      data.destDir = params.dataDestDir;
    }
    img.buildFilePath = path.join(img.destDir, params.imgBuildFile);
    data.buildFilePath = path.join(data.destDir, params.dataBuildFile);
    img.publicPath = img.buildFilePath;
    if (params.imgPublicPath != null) {
      img.publicPath = params.imgPublicPath;
    }
    cb(img, data);
  };
  spriteCleanTask = function(name, spriteParams, params, cb){
    spritePreparePaths(params, function(img, data){
      var toRemove;
      toRemove = [data.buildFilePath].concat([params.imgDestDir != null && img.buildFilePath || img.destDir]);
      del(toRemove, {
        force: true
      }, cb);
    });
  };
  spriteBuildTask = function(name, spriteParams, params, cb){
    spritePreparePaths(params, function(img, css){
      var spriteData, ready, postCb;
      spriteData = gulp.src(path.join(img.srcDir, '*.png')).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(require('gulp.spritesmith')(spriteParams));
      ready = {
        img: false,
        css: false
      };
      postCb = function(){
        if (ready.img && ready.css) {
          cb();
        }
      };
      spriteData.img.pipe(gulp.dest(img.destDir)).pipe(gcb(function(){
        ready.img = true;
        postCb();
      }));
      spriteData.css.pipe(gulp.dest(css.destDir)).pipe(gcb(function(){
        ready.css = true;
        postCb();
      }));
    });
  };
  spriteGetNameByMask = function(name, s, mask){
    return Object.keys(s).reduce(function(result, key){
      return result.replace(new RegExp("\\#" + key + "\\#", 'g'), s[key]);
    }, mask.replace(new RegExp('\\#task-name\\#', 'g'), name));
  };
  spriteInitTasks = function(name, item, subTask){
    var params;
    subTask == null && (subTask = false);
    params = {
      path: item.path || null,
      imgBuildFile: item.imgBuildFile || 'build.png',
      imgSrcDir: item.imgSrcDir || null,
      imgDestDir: item.imgDestDir || null,
      dataBuildFile: item.dataBuildFile || 'build.json',
      dataDestDir: item.dataDestDir || null,
      imgPublicPath: item.imgPublicPath || null,
      dataItemNameMask: item.dataItemNameMask || 'sprite-#task-name#-#name#'
    };
    spritePreparePaths(params, function(img){
      var spriteParams, cleanTaskName, buildTaskName, watchTaskName, preBuildTasks, ref$, watchFiles;
      spriteParams = {
        imgName: params.imgBuildFile,
        cssName: params.dataBuildFile,
        imgPath: img.publicPath,
        padding: item.padding || 1,
        algorithm: item.algorithm || 'top-down',
        imgOpts: {
          format: 'png'
        },
        cssFormat: item.dataType || void 8,
        cssVarMap: (function(name){
          return function(s){
            s.name = spriteGetNameByMask(name, s, params.dataItemNameMask);
          };
        }.call(this, name))
      };
      cleanTaskName = "clean-sprite-" + name;
      buildTaskName = "sprite-" + name;
      watchTaskName = buildTaskName + "-watch";
      preBuildTasks = [cleanTaskName].concat((ref$ = item.buildDeps) != null
        ? ref$
        : []);
      gulp.task(cleanTaskName, (function(name, spriteParams, params){
        return function(cb){
          spriteCleanTask(name, spriteParams, params, cb);
        };
      }.call(this, name, spriteParams, params)));
      gulp.task(buildTaskName, preBuildTasks, (function(name, spriteParams, params){
        return function(cb){
          spriteBuildTask(name, spriteParams, params, cb);
        };
      }.call(this, name, spriteParams, params)));
      spritesCleanTasks.push(cleanTaskName);
      if (!subTask) {
        spritesBuildTasks.push(buildTaskName);
      }
      watchFiles = (ref$ = item.watchFiles) != null
        ? ref$
        : path.join(img.srcDir, '*.png');
      initWatcherTask(subTask, watchFiles, item.addToWatchersList, watchTaskName, spritesWatchTasks, buildTaskName);
    });
  };
  for (name in spritesData) {
    item = spritesData[name];
    initTaskIteration(name, item, spriteInitTasks);
  }
  if (spritesCleanTasks.length > 0) {
    gulp.task('clean-sprites', spritesCleanTasks);
    cleanTasks.push('clean-sprites');
  }
  if (spritesBuildTasks.length > 0) {
    gulp.task('sprites', spritesBuildTasks);
    defaultTasks.push('sprites');
  }
  if (spritesWatchTasks.length > 0) {
    gulp.task('sprites-watch', spritesWatchTasks);
    watchTasks.push('sprites-watch');
  }
  stylesCleanTasks = [];
  stylesBuildTasks = [];
  stylesWatchTasks = [];
  stylesData = (ref$ = pkg.gulp.styles) != null
    ? ref$
    : {};
  stylesCleanTask = typicalCleanTask;
  stylesBuildTask = function(name, params, cb){
    preparePaths(params, function(srcFilePath, srcDir, destDir){
      var options, sourceMaps, sourceMapsAsPlugin, plugin, i$, ref$, len$, modulePath;
      options = {
        compress: isProductionMode
      };
      sourceMaps = false;
      if (params.sourceMaps === true) {
        sourceMaps = true;
      } else if (!isProductionMode && params.sourceMaps !== false) {
        sourceMaps = true;
      }
      sourceMapsAsPlugin = false;
      plugin = null;
      switch (false) {
      case params.type !== 'stylus':
        if (params.shim != null) {
          options.use = [];
          for (i$ = 0, len$ = (ref$ = params.shim).length; i$ < len$; ++i$) {
            modulePath = ref$[i$];
            options.use.push(require(path.join(process.cwd(), modulePath)));
          }
        }
        if (sourceMaps) {
          sourceMapsAsPlugin = true;
        }
        plugin = require('gulp-stylus');
        break;
      case params.type !== 'less':
        if (sourceMaps) {
          sourceMapsAsPlugin = true;
        }
        plugin = require('gulp-less');
        break;
      default:
        throw Error('unimplemented');
      }
      gulp.src(srcFilePath).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(gulpif(sourceMapsAsPlugin, sourcemaps.init())).pipe(plugin(options)).pipe(gulpif(sourceMapsAsPlugin, sourcemaps.write())).pipe(rename(function(buildPath){
        renameBuildFile(buildPath, params.mainSrc, params.buildFile);
      })).pipe(gulp.dest(destDir)).pipe(gcb(cb));
    });
  };
  stylesInitTasks = function(name, item, subTask){
    var params, cleanTaskName, buildTaskName, watchTaskName, preBuildTasks, i$, ref$, len$, taskName;
    subTask == null && (subTask = false);
    params = {
      type: item.type,
      path: item.path,
      mainSrc: item.mainSrc,
      srcDir: item.srcDir || null,
      buildFile: item.buildFile,
      destDir: item.destDir || null,
      shim: item.shim || null
    };
    checkForSupportedType('styles')(
    params.type);
    if (typeof item.sourceMaps === 'boolean') {
      params.sourceMaps = item.sourceMaps;
    }
    cleanTaskName = 'clean-styles-' + name;
    buildTaskName = 'styles-' + name;
    watchTaskName = buildTaskName + '-watch';
    preBuildTasks = [cleanTaskName];
    if (item.buildDeps != null) {
      for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
        taskName = ref$[i$];
        preBuildTasks.push(taskName);
      }
    }
    gulp.task(cleanTaskName, (function(name, params){
      return function(cb){
        stylesCleanTask(name, params, cb);
      };
    }.call(this, name, params)));
    gulp.task(buildTaskName, preBuildTasks, (function(name, params){
      return function(cb){
        stylesBuildTask(name, params, cb);
      };
    }.call(this, name, params)));
    stylesCleanTasks.push(cleanTaskName);
    if (!subTask) {
      stylesBuildTasks.push(buildTaskName);
    }
    preparePaths(params, function(srcFilePath, srcDir){
      var watchFiles;
      switch (false) {
      case item.watchFiles == null:
        watchFiles = item.watchFiles;
        break;
      case item.type !== 'less':
        watchFiles = path.join(srcDir, '**/*.less');
        break;
      case item.type !== 'stylus':
        watchFiles = [path.join(srcDir, '**/*.styl'), path.join(srcDir, '**/*.stylus')];
        break;
      default:
        throw Error('unimplemented');
      }
      initWatcherTask(subTask, watchFiles, item.addToWatchersList, watchTaskName, stylesWatchTasks, buildTaskName);
    });
  };
  for (name in stylesData) {
    item = stylesData[name];
    initTaskIteration(name, item, stylesInitTasks);
  }
  if (stylesCleanTasks.length > 0) {
    gulp.task('clean-styles', stylesCleanTasks);
    cleanTasks.push('clean-styles');
  }
  if (stylesBuildTasks.length > 0) {
    gulp.task('styles', stylesBuildTasks);
    defaultTasks.push('styles');
  }
  if (stylesWatchTasks.length > 0) {
    gulp.task('styles-watch', stylesWatchTasks);
    watchTasks.push('styles-watch');
  }
  scriptsCleanTasks = [];
  scriptsBuildTasks = [];
  scriptsWatchTasks = [];
  scriptsData = (ref$ = pkg.gulp.scripts) != null
    ? ref$
    : {};
  scriptsCleanTask = typicalCleanTask;
  scriptsJshintTask = function(name, params, cb){
    preparePaths(params, function(srcFilePath, srcDir){
      var jshint, stylish, src, i$, ref$, len$, exclude;
      jshint = require('gulp-jshint');
      stylish = require('jshint-stylish');
      src = [path.join(srcDir, '**/*.js')];
      for (i$ = 0, len$ = (ref$ = params.jshintExclude).length; i$ < len$; ++i$) {
        exclude = ref$[i$];
        src.push('!' + exclude);
      }
      gulp.src(src).pipe(jshint(params.jshintParams)).pipe(jshint.reporter(stylish)).pipe(rename('x')).end(cb);
    });
  };
  scriptsBuildBrowserifyTask = function(name, params, cb){
    var options;
    options = {
      shim: params.shim,
      debug: false
    };
    if (params.debug === true) {
      options.debug = true;
    } else if (!isProductionMode && params.debug !== false) {
      options.debug = true;
    }
    if (params.transform != null) {
      options.transform = params.transform;
    }
    if (params.extensions != null) {
      options.extensions = params.extensions;
    }
    preparePaths(params, function(srcFilePath, srcDir, destDir){
      gulp.src(srcFilePath, {
        read: false
      }).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(require('gulp-browserify')(options)).pipe(gulpif(isProductionMode, require('gulp-uglify')({
        preserveComments: 'some'
      }))).pipe(rename(function(buildPath){
        renameBuildFile(buildPath, params.mainSrc, params.buildFile);
      })).pipe(gulp.dest(destDir)).pipe(gcb(cb));
    });
  };
  scriptsInitTasks = function(name, item, subTask){
    var params;
    subTask == null && (subTask = false);
    params = {
      type: item.type,
      path: item.path,
      mainSrc: item.mainSrc,
      srcDir: item.srcDir || null,
      buildFile: item.buildFile,
      destDir: item.destDir || null,
      shim: item.shim || {},
      jshintDisabled: item.jshintDisabled && true || false,
      jshintParams: item.jshintParams || null,
      jshintExclude: item.jshintExclude || [],
      transform: item.transform || null,
      extensions: item.extensions || null
    };
    checkForSupportedType('scripts')(
    params.type);
    preparePaths(params, function(srcFilePath, srcDir){
      var key, ref$, shimItem, paramName, val, i$, len$, exclude, cleanTaskName, buildTaskName, jshintTaskName, watchTaskName, preBuildTasks, taskName, watchFiles, ext;
      if (item.shim != null) {
        for (key in ref$ = params.shim) {
          shimItem = ref$[key];
          for (paramName in shimItem) {
            val = shimItem[paramName];
            if (paramName === 'relativePath') {
              shimItem.path = path.join(srcDir, val);
              delete shimItem[paramName];
            }
          }
        }
      }
      if (item.jshintRelativeExclude) {
        for (i$ = 0, len$ = (ref$ = item.jshintRelativeExclude).length; i$ < len$; ++i$) {
          exclude = ref$[i$];
          params.jshintExclude.push(path.join(srcDir, exclude));
        }
      }
      if (typeof item.debug === 'boolean') {
        params.debug = item.debug;
      }
      cleanTaskName = "clean-scripts-" + name;
      buildTaskName = "scripts-" + name;
      jshintTaskName = buildTaskName + "-jshint";
      watchTaskName = buildTaskName + "-watch";
      preBuildTasks = [cleanTaskName];
      if (item.buildDeps != null) {
        for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
          taskName = ref$[i$];
          preBuildTasks.push(taskName);
        }
      }
      if (!params.jshintDisabled) {
        gulp.task(jshintTaskName, (function(name, params){
          return function(cb){
            scriptsJshintTask(name, params, cb);
          };
        }.call(this, name, params)));
        preBuildTasks.push(jshintTaskName);
      }
      gulp.task(cleanTaskName, (function(name, params){
        return function(cb){
          scriptsCleanTask(name, params, cb);
        };
      }.call(this, name, params)));
      if (item.type === 'browserify') {
        gulp.task(buildTaskName, preBuildTasks, (function(name, params){
          return function(cb){
            scriptsBuildBrowserifyTask(name, params, cb);
          };
        }.call(this, name, params)));
      } else {
        throw Error('unimplemented');
      }
      scriptsCleanTasks.push(cleanTaskName);
      if (!subTask) {
        scriptsBuildTasks.push(buildTaskName);
      }
      switch (false) {
      case item.watchFiles == null:
        watchFiles = item.watchFiles;
        break;
      case item.type !== 'browserify':
        watchFiles = [path.join(srcDir, '**/*.js')];
        if (params.extensions) {
          for (i$ = 0, len$ = (ref$ = params.extensions).length; i$ < len$; ++i$) {
            ext = ref$[i$];
            watchFiles.push(path.join(srcDir, '**/*' + ext));
          }
        }
        break;
      default:
        throw Error('unimplemented');
      }
      initWatcherTask(subTask, watchFiles, item.addToWatchersList, watchTaskName, scriptsWatchTasks, buildTaskName);
    });
  };
  for (name in scriptsData) {
    item = scriptsData[name];
    initTaskIteration(name, item, scriptsInitTasks);
  }
  if (scriptsCleanTasks.length > 0) {
    gulp.task('clean-scripts', scriptsCleanTasks);
    cleanTasks.push('clean-scripts');
  }
  if (scriptsBuildTasks.length > 0) {
    gulp.task('scripts', scriptsBuildTasks);
    defaultTasks.push('scripts');
  }
  if (scriptsWatchTasks.length > 0) {
    gulp.task('scripts-watch', scriptsWatchTasks);
    watchTasks.push('scripts-watch');
  }
  cleanData = (ref$ = pkg.gulp.clean) != null
    ? ref$
    : [];
  distCleanData = (ref$ = pkg.gulp.distclean) != null
    ? ref$
    : [];
  distCleanTasks = [];
  if (cleanData.length > 0 || cleanTasks.length > 0) {
    gulp.task('clean', cleanTasks, function(cb){
      del(cleanData, cb);
    });
    distCleanTasks.push('clean');
  }
  if (distCleanTasks.length > 0 || distCleanData.length > 0) {
    gulp.task('distclean', distCleanTasks, function(cb){
      del(distCleanData, cb);
    });
  }
  if (watchTasks.length > 0) {
    gulp.task('watch', watchTasks);
  }
  if (defaultTasks.length > 0) {
    gulp.task('default', defaultTasks);
  }
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
