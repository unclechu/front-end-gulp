// Generated by LiveScript 1.3.1
/**
 * @version r11
 * @author Viacheslav Lotsmanov
 * @license GNU/GPLv3 (https://raw.githubusercontent.com/unclechu/front-end-gulp-pattern/master/LICENSE)
 * @see {@link https://github.com/unclechu/front-end-gulp-pattern|GitHub}
 */
(function(){
  var path, fs, argv, gulp, del, tasks, gcb, plumber, gulpif, rename, sourcemaps, pkg, production, ignoreErrors, supportedTypes, watchTasks, defaultTasks, cleanTasks, renameBuildFile, initTaskIteration, initWatcherTask, preparePaths, checkForSupportedType, typicalCleanTask, spritesCleanTasks, spritesBuildTasks, spritesData, spritePreparePaths, spriteCleanTask, spriteBuildTask, spriteGetNameByMask, spriteInitTasks, name, item, stylesCleanTasks, stylesBuildTasks, stylesWatchTasks, stylesData, stylesCleanTask, stylesBuildTask, stylesInitTasks, scriptsCleanTasks, scriptsBuildTasks, scriptsWatchTasks, scriptsData, scriptsCleanTask, scriptsJshintTask, scriptsBuildBrowserifyTask, scriptsInitTasks, cleanData, distCleanData, distCleanTasks;
  path = require('path');
  fs = require('fs');
  argv = require('yargs').argv;
  gulp = require('gulp');
  del = require('del');
  tasks = require('gulp-task-listing');
  gcb = require('gulp-callback');
  plumber = require('gulp-plumber');
  gulpif = require('gulp-if');
  rename = require('gulp-rename');
  sourcemaps = require('gulp-sourcemaps');
  pkg = require(path.join(process.cwd(), './package.json'));
  if (pkg.gulp == null) {
    throw new Error('No "gulp" key in package.json');
  }
  gulp.task('help', tasks);
  production = argv.production != null;
  ignoreErrors = argv['ignore-errors'] != null;
  supportedTypes = {
    styles: ['stylus', 'less'],
    scripts: ['browserify', 'liveify']
  };
  watchTasks = [];
  defaultTasks = [];
  cleanTasks = [];
  renameBuildFile = function(buildPath, mainSrc, buildFile){
    if (buildPath.basename === path.basename(mainSrc, path.extname(mainSrc))) {
      buildPath.extname = path.extname(buildFile);
      buildPath.basename = path.basename(buildFile, buildPath.extname);
    }
  };
  initTaskIteration = function(name, item, initFunc){
    var subTaskName, ref$, subTask, subTaskParams, key, val;
    initFunc(name, item);
    if (item.subTasks) {
      for (subTaskName in ref$ = item.subTasks) {
        subTask = ref$[subTaskName];
        subTaskParams = clone$(item);
        subTaskParams.subTask = null;
        for (key in subTask) {
          val = subTask[key];
          subTaskParams[key] = val;
        }
        initFunc(name + '-' + subTaskName, subTaskParams, true);
      }
    }
  };
  initWatcherTask = function(subTask, watchFiles, addToWatchersList, watchTaskName, watchersList, buildTaskName){
    var addToList;
    addToList = false;
    if (addToWatchersList === true) {
      addToList = true;
    } else if (!subTask && addToWatchersList !== false) {
      addToList = true;
    }
    gulp.task(watchTaskName, function(){
      ignoreErrors = true;
      gulp.watch(watchFiles, [buildTaskName]);
    });
    if (addToList) {
      watchersList.push(watchTaskName);
    }
  };
  preparePaths = function(params, cb){
    var destDir, srcDir, srcFilePath, exists;
    destDir = path.join(params.path, 'build');
    if (params.destDir != null) {
      destDir = params.destDir;
    }
    srcDir = path.join(params.path, 'src');
    if (params.srcDir != null) {
      srcDir = params.srcDir;
    }
    srcFilePath = path.join(srcDir, params.mainSrc);
    exists = fs.existsSync(srcFilePath);
    if (!exists) {
      throw new Error("Source file '" + srcFilePath + "' is not exists");
    }
    cb(srcFilePath, srcDir, destDir);
  };
  checkForSupportedType = curry$(function(category, type){
    if (supportedTypes[category] == null) {
      throw new Error("Unknown category: '" + category + "'");
    }
    if (!(function(it){
      return in$(it, supportedTypes[category]);
    })(
    type)) {
      throw new Error("Unknown " + category + " type: '" + type + "'");
    }
  });
  typicalCleanTask = function(name, params, cb){
    preparePaths(params, function(srcFilePath, srcDir, destDir){
      var toRemove;
      if (params.destDir != null) {
        toRemove = path.join(destDir, params.buildFile);
      } else {
        toRemove = destDir;
      }
      del(toRemove, {
        force: true
      }, cb);
    });
  };
  spritesCleanTasks = [];
  spritesBuildTasks = [];
  spritesData = pkg.gulp.sprites || {};
  spritePreparePaths = function(params, cb){
    var img, data;
    img = {};
    data = {};
    if (params.path == null) {
      if (params.imgSrcDir == null || params.imgDestDir == null || params.dataDestDir == null) {
        throw new Error('Not enough parameters');
      }
    } else {
      img.srcDir = path.join(params.path, 'src');
      img.destDir = path.join(params.path, 'build');
      data.destDir = path.join(params.path, 'build');
    }
    if (params.imgSrcDir != null) {
      img.srcDir = params.imgSrcDir;
    }
    if (params.imgDestDir != null) {
      img.destDir = params.imgDestDir;
    }
    if (params.dataDestDir != null) {
      data.destDir = params.dataDestDir;
    }
    img.buildFilePath = path.join(img.destDir, params.imgBuildFile);
    data.buildFilePath = path.join(data.destDir, params.dataBuildFile);
    img.publicPath = img.buildFilePath;
    if (params.imgPublicPath != null) {
      img.publicPath = params.imgPublicPath;
    }
    cb(img, data);
  };
  spriteCleanTask = function(name, spriteParams, params, cb){
    spritePreparePaths(params, function(img, data){
      var toRemove;
      toRemove = [data.buildFilePath];
      if (params.imgDestDir != null) {
        toRemove.push(img.buildFilePath);
      } else {
        toRemove.push(img.destDir);
      }
      del(toRemove, {
        force: true
      }, cb);
    });
  };
  spriteBuildTask = function(name, spriteParams, params, cb){
    spritePreparePaths(params, function(img, data){
      var spriteData, ready, postCb;
      spriteData = gulp.src(path.join(img.srcDir, '*.png')).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(require('gulp.spritesmith')(spriteParams));
      ready = {
        img: false,
        data: false
      };
      postCb = function(){
        if (!ready.img || !ready.data) {
          return;
        }
        cb();
      };
      spriteData.img.pipe(gulp.dest(img.destDir)).pipe(gcb(function(){
        ready.img = true;
        postCb();
      }));
      spriteData.css.pipe(gulp.dest(data.destDir)).pipe(gcb(function(){
        ready.data = true;
        postCb();
      }));
    });
  };
  spriteGetNameByMask = function(name, s, mask){
    var reg, result, item;
    reg = new RegExp("\\#task-name\\#", 'g');
    result = '' + mask.replace(reg, name);
    for (item in s) {
      reg = new RegExp("\\#" + item + "\\#", 'g');
      result = result.replace(reg, s[item]);
    }
    return result;
  };
  spriteInitTasks = function(name, item, subTask){
    var params;
    subTask == null && (subTask = false);
    params = {
      path: item.path || null,
      imgBuildFile: item.imgBuildFile || 'build.png',
      imgSrcDir: item.imgSrcDir || null,
      imgDestDir: item.imgDestDir || null,
      dataBuildFile: item.dataBuildFile || 'build.json',
      dataDestDir: item.dataDestDir || null,
      imgPublicPath: item.imgPublicPath || null,
      dataItemNameMask: item.dataItemNameMask || 'sprite-#task-name#-#name#'
    };
    spritePreparePaths(params, function(img, data){
      var spriteParams, cleanTaskName, buildTaskName, preBuildTasks, i$, ref$, len$, taskName;
      spriteParams = {
        imgName: params.imgBuildFile,
        cssName: params.dataBuildFile,
        imgPath: img.publicPath,
        padding: item.padding || 1,
        algorithm: item.algorithm || 'top-down',
        imgOpts: {
          format: 'png'
        },
        cssFormat: item.dataType || void 8,
        cssVarMap: (function(name){
          return function(s){
            s.name = spriteGetNameByMask(name, s, params.dataItemNameMask);
          };
        }.call(this, name))
      };
      cleanTaskName = 'clean-sprite-' + name;
      buildTaskName = 'sprite-' + name;
      preBuildTasks = [cleanTaskName];
      if (item.buildDeps != null) {
        for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
          taskName = ref$[i$];
          preBuildTasks.push(taskName);
        }
      }
      gulp.task(cleanTaskName, (function(name, spriteParams, params){
        return function(cb){
          spriteCleanTask(name, spriteParams, params, cb);
        };
      }.call(this, name, spriteParams, params)));
      gulp.task(buildTaskName, preBuildTasks, (function(name, spriteParams, params){
        return function(cb){
          spriteBuildTask(name, spriteParams, params, cb);
        };
      }.call(this, name, spriteParams, params)));
      spritesCleanTasks.push(cleanTaskName);
      if (!subTask) {
        spritesBuildTasks.push(buildTaskName);
      }
    });
  };
  for (name in spritesData) {
    item = spritesData[name];
    initTaskIteration(name, item, spriteInitTasks);
  }
  if (spritesCleanTasks.length > 0) {
    gulp.task('clean-sprites', spritesCleanTasks);
    cleanTasks.push('clean-sprites');
  }
  if (spritesBuildTasks.length > 0) {
    gulp.task('sprites', spritesBuildTasks);
    defaultTasks.push('sprites');
  }
  stylesCleanTasks = [];
  stylesBuildTasks = [];
  stylesWatchTasks = [];
  stylesData = pkg.gulp.styles || {};
  stylesCleanTask = typicalCleanTask;
  stylesBuildTask = function(name, params, cb){
    preparePaths(params, function(srcFilePath, srcDir, destDir){
      var options, sourceMaps, sourceMapsAsPlugin, plugin, i$, ref$, len$, modulePath;
      options = {
        compress: production
      };
      sourceMaps = false;
      if (params.sourceMaps === true) {
        sourceMaps = true;
      } else if (!production && params.sourceMaps !== false) {
        sourceMaps = true;
      }
      sourceMapsAsPlugin = false;
      plugin = null;
      switch (false) {
      case params.type !== 'stylus':
        if (params.shim != null) {
          options.use = [];
          for (i$ = 0, len$ = (ref$ = params.shim).length; i$ < len$; ++i$) {
            modulePath = ref$[i$];
            options.use.push(require(path.join(process.cwd(), modulePath)));
          }
        }
        if (sourceMaps) {
          options.sourcemap = {
            inline: true,
            sourceRoot: '.',
            basePath: path.join(srcDir)
          };
        }
        plugin = require('gulp-stylus');
        break;
      case params.type !== 'less':
        if (sourceMaps) {
          sourceMapsAsPlugin = true;
        }
        plugin = require('gulp-less');
        break;
      default:
        throw Error('unimplemented');
      }
      gulp.src(srcFilePath).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(gulpif(sourceMapsAsPlugin, sourcemaps.init())).pipe(plugin(options)).pipe(gulpif(sourceMapsAsPlugin, sourcemaps.write())).pipe(rename(function(buildPath){
        renameBuildFile(buildPath, params.mainSrc, params.buildFile);
      })).pipe(gulp.dest(destDir)).pipe(gcb(cb));
    });
  };
  stylesInitTasks = function(name, item, subTask){
    var params, cleanTaskName, buildTaskName, watchTaskName, preBuildTasks, i$, ref$, len$, taskName;
    subTask == null && (subTask = false);
    params = {
      type: item.type,
      path: item.path,
      mainSrc: item.mainSrc,
      srcDir: item.srcDir || null,
      buildFile: item.buildFile,
      destDir: item.destDir || null,
      shim: item.shim || null
    };
    checkForSupportedType('styles')(
    params.type);
    if (typeof item.sourceMaps === 'boolean') {
      params.sourceMaps = item.sourceMaps;
    }
    cleanTaskName = 'clean-styles-' + name;
    buildTaskName = 'styles-' + name;
    watchTaskName = buildTaskName + '-watch';
    preBuildTasks = [cleanTaskName];
    if (item.buildDeps != null) {
      for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
        taskName = ref$[i$];
        preBuildTasks.push(taskName);
      }
    }
    gulp.task(cleanTaskName, (function(name, params){
      return function(cb){
        stylesCleanTask(name, params, cb);
      };
    }.call(this, name, params)));
    gulp.task(buildTaskName, preBuildTasks, (function(name, params){
      return function(cb){
        stylesBuildTask(name, params, cb);
      };
    }.call(this, name, params)));
    stylesCleanTasks.push(cleanTaskName);
    if (!subTask) {
      stylesBuildTasks.push(buildTaskName);
    }
    preparePaths(params, function(srcFilePath, srcDir){
      var watchFiles;
      switch (false) {
      case item.watchFiles == null:
        watchFiles = item.watchFiles;
        break;
      case item.type !== 'less':
        watchFiles = path.join(srcDir, '**/*.less');
        break;
      case item.type !== 'stylus':
        watchFiles = [path.join(srcDir, '**/*.styl'), path.join(srcDir, '**/*.stylus')];
        break;
      default:
        throw Error('unimplemented');
      }
      initWatcherTask(subTask, watchFiles, item.addToWatchersList, watchTaskName, stylesWatchTasks, buildTaskName);
    });
  };
  for (name in stylesData) {
    item = stylesData[name];
    initTaskIteration(name, item, stylesInitTasks);
  }
  if (stylesCleanTasks.length > 0) {
    gulp.task('clean-styles', stylesCleanTasks);
    cleanTasks.push('clean-styles');
  }
  if (stylesBuildTasks.length > 0) {
    gulp.task('styles', stylesBuildTasks);
    defaultTasks.push('styles');
  }
  if (stylesWatchTasks.length > 0) {
    gulp.task('styles-watch', stylesWatchTasks);
    watchTasks.push('styles-watch');
  }
  scriptsCleanTasks = [];
  scriptsBuildTasks = [];
  scriptsWatchTasks = [];
  scriptsData = pkg.gulp.scripts || {};
  scriptsCleanTask = typicalCleanTask;
  scriptsJshintTask = function(name, params, cb){
    preparePaths(params, function(srcFilePath, srcDir){
      var jshint, stylish, src, i$, ref$, len$, exclude;
      jshint = require('gulp-jshint');
      stylish = require('jshint-stylish');
      src = [path.join(srcDir, '**/*.js')];
      for (i$ = 0, len$ = (ref$ = params.jshintExclude).length; i$ < len$; ++i$) {
        exclude = ref$[i$];
        src.push('!' + exclude);
      }
      gulp.src(src).pipe(jshint(params.jshintParams)).pipe(jshint.reporter(stylish)).pipe(rename('x')).end(cb);
    });
  };
  scriptsBuildBrowserifyTask = function(name, params, cb){
    var options;
    options = {
      shim: params.shim,
      debug: false
    };
    if (params.debug === true) {
      options.debug = true;
    } else if (!production && params.debug !== false) {
      options.debug = true;
    }
    if (params.type === 'liveify') {
      options.transform = ['liveify'];
      options.extensions = ['.ls'];
    }
    preparePaths(params, function(srcFilePath, srcDir, destDir){
      gulp.src(srcFilePath, {
        read: false
      }).pipe(gulpif(ignoreErrors, plumber({
        errorHandler: cb
      }))).pipe(require('gulp-browserify')(options)).pipe(gulpif(production, require('gulp-uglify')({
        preserveComments: 'some'
      }))).pipe(rename(function(buildPath){
        renameBuildFile(buildPath, params.mainSrc, params.buildFile);
      })).pipe(gulp.dest(destDir)).pipe(gcb(cb));
    });
  };
  scriptsInitTasks = function(name, item, subTask){
    var params;
    subTask == null && (subTask = false);
    params = {
      type: item.type,
      path: item.path,
      mainSrc: item.mainSrc,
      srcDir: item.srcDir || null,
      buildFile: item.buildFile,
      destDir: item.destDir || null,
      shim: item.shim || {},
      jshintDisabled: item.jshintDisabled && true || false,
      jshintParams: item.jshintParams || null,
      jshintExclude: item.jshintExclude || []
    };
    checkForSupportedType('scripts')(
    params.type);
    preparePaths(params, function(srcFilePath, srcDir){
      var key, ref$, shimItem, paramName, val, liveify, i$, len$, exclude, cleanTaskName, buildTaskName, jshintTaskName, watchTaskName, preBuildTasks, taskName, watchFiles;
      if (item.shim != null) {
        for (key in ref$ = params.shim) {
          shimItem = ref$[key];
          for (paramName in shimItem) {
            val = shimItem[paramName];
            if (paramName === 'relativePath') {
              shimItem.path = path.join(srcDir, val);
              delete shimItem[paramName];
            }
          }
        }
      }
      if (params.type === 'liveify') {
        liveify = require('liveify');
        params.jshintExclude.push(path.join(srcDir, '**/*.ls'));
      }
      if (item.jshintRelativeExclude) {
        for (i$ = 0, len$ = (ref$ = item.jshintRelativeExclude).length; i$ < len$; ++i$) {
          exclude = ref$[i$];
          params.jshintExclude.push(path.join(srcDir, exclude));
        }
      }
      if (typeof item.debug === 'boolean') {
        params.debug = item.debug;
      }
      cleanTaskName = 'clean-scripts-' + name;
      buildTaskName = 'scripts-' + name;
      jshintTaskName = buildTaskName + '-jshint';
      watchTaskName = buildTaskName + '-watch';
      preBuildTasks = [cleanTaskName];
      if (item.buildDeps != null) {
        for (i$ = 0, len$ = (ref$ = item.buildDeps).length; i$ < len$; ++i$) {
          taskName = ref$[i$];
          preBuildTasks.push(taskName);
        }
      }
      if (!params.jshintDisabled) {
        gulp.task(jshintTaskName, (function(name, params){
          return function(cb){
            scriptsJshintTask(name, params, cb);
          };
        }.call(this, name, params)));
        preBuildTasks.push(jshintTaskName);
      }
      gulp.task(cleanTaskName, (function(name, params){
        return function(cb){
          scriptsCleanTask(name, params, cb);
        };
      }.call(this, name, params)));
      if ((function(it){
        return it === 'browserify' || it === 'liveify';
      })(
      item.type)) {
        gulp.task(buildTaskName, preBuildTasks, (function(name, params){
          return function(cb){
            scriptsBuildBrowserifyTask(name, params, cb);
          };
        }.call(this, name, params)));
      } else {
        throw Error('unimplemented');
      }
      scriptsCleanTasks.push(cleanTaskName);
      if (!subTask) {
        scriptsBuildTasks.push(buildTaskName);
      }
      switch (false) {
      case item.watchFiles == null:
        watchFiles = item.watchFiles;
        break;
      case item.type !== 'browserify':
        watchFiles = path.join(srcDir, '**/*.js');
        break;
      case item.type !== 'liveify':
        watchFiles = [path.join(srcDir, '**/*.ls'), path.join(srcDir, '**/*.js')];
        break;
      default:
        throw Error('unimplemented');
      }
      initWatcherTask(subTask, watchFiles, item.addToWatchersList, watchTaskName, scriptsWatchTasks, buildTaskName);
    });
  };
  for (name in scriptsData) {
    item = scriptsData[name];
    initTaskIteration(name, item, scriptsInitTasks);
  }
  if (scriptsCleanTasks.length > 0) {
    gulp.task('clean-scripts', scriptsCleanTasks);
    cleanTasks.push('clean-scripts');
  }
  if (scriptsBuildTasks.length > 0) {
    gulp.task('scripts', scriptsBuildTasks);
    defaultTasks.push('scripts');
  }
  if (scriptsWatchTasks.length > 0) {
    gulp.task('scripts-watch', scriptsWatchTasks);
    watchTasks.push('scripts-watch');
  }
  cleanData = pkg.gulp.clean || [];
  distCleanData = pkg.gulp.distclean || [];
  distCleanTasks = [];
  if (cleanData.length > 0 || cleanTasks.length > 0) {
    gulp.task('clean', cleanTasks, function(cb){
      del(cleanData, cb);
    });
    distCleanTasks.push('clean');
  }
  if (distCleanTasks.length > 0 || distCleanData.length > 0) {
    gulp.task('distclean', distCleanTasks, function(cb){
      del(distCleanData, cb);
    });
  }
  if (watchTasks.length > 0) {
    gulp.task('watch', watchTasks);
  }
  if (defaultTasks.length > 0) {
    gulp.task('default', defaultTasks);
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
